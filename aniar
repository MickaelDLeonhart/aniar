#!/usr/bin/env bash
# aniar - Arabic Anime Streaming Tool
# Created by Mickael D Leonhart
# GitHub: https://github.com/MickaelDLeonhart/aniar

set -e

# ==================== CONFIGURATION ====================
VERSION="1.0.0"
AUTHOR="Mickael D Leonhart"
GITHUB_URL="https://github.com/MickaelDLeonhart/aniar"
OKANIME_BASE="https://ok.okanime.xyz"
PREFERRED_SOURCES=("videa.hu" "drive.google.com" "ok.ru" "solidfiles.com" "mp4upload.com" "4shared.com")
DEFAULT_PLAYER="mpv"
USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
DEBUG_MODE=0

# Config directory
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/aniar"
CONFIG_FILE="$CONFIG_DIR/config"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/aniar"
HISTORY_FILE="$CONFIG_DIR/history"

# ASCII Art
show_banner() {
    cat << "EOF"
    _    _ _ 
   / \  | (_) __ _ 
  / _ \ | | |/ _` |
 / ___ \| | | (_| |
/_/   \_\_|_|\__,_|
Arabic Anime Streaming Tool
EOF
    echo -e "v$VERSION | By $AUTHOR\n"
}

# ==================== LOGGING FUNCTIONS ====================

log() { printf "\033[1;34m>>\033[0m %s\n" "$*" >&2; }
warn() { printf "\033[1;33m!\033[0m %s\n" "$*" >&2; }
die() { printf "\033[1;31mERROR:\033[0m %s\n" "$*" >&2; exit 1; }
debug() { 
    [ "$DEBUG_MODE" -eq 1 ] && printf "\033[1;36mDEBUG:\033[0m %s\n" "$*" >&2
    return 0
}

# ==================== UTILITY FUNCTIONS ====================

setup_directories() {
    mkdir -p "$CONFIG_DIR" "$CACHE_DIR"
    [ ! -f "$CONFIG_FILE" ] && create_default_config
    [ ! -f "$HISTORY_FILE" ] && touch "$HISTORY_FILE"
}

create_default_config() {
    cat > "$CONFIG_FILE" << 'EOF'
# aniar Configuration File
# Created by Mickael D Leonhart
# GitHub: https://github.com/MickaelDLeonhart/aniar

# Preferred video sources (in order of preference)
# PREFERRED_SOURCES=("videa.hu" "drive.google.com" "ok.ru" "solidfiles.com")

# Video player and options
# DEFAULT_PLAYER="mpv"
# MPV_OPTIONS="--force-window=yes --keep-open=yes"

# Video quality preference (best, worst, 720p, 480p, etc)
# QUALITY="best"

# Subtitle language preference (ar, en, none)
# SUBTITLE_LANG="ar"

# Auto-play next episode
# AUTO_NEXT=false

# Default anime directory for downloads
# DOWNLOAD_DIR="$HOME/Anime"

# Enable/disable watch history
# TRACK_HISTORY=true
EOF
    log "Created default config at $CONFIG_FILE"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
    fi
}

# Cache functions
cache_get() {
    local key="$1"
    local cache_file="$CACHE_DIR/$(echo -n "$key" | md5sum | cut -d' ' -f1)"
    [ -f "$cache_file" ] && cat "$cache_file"
}

cache_set() {
    local key="$1"
    local value="$2"
    local cache_file="$CACHE_DIR/$(echo -n "$key" | md5sum | cut -d' ' -f1)"
    echo "$value" > "$cache_file"
}

# History tracking
add_to_history() {
    [ "${TRACK_HISTORY:-true}" = "false" ] && return
    
    local series="$1"
    local episode="$2"
    local title="$3"
    local timestamp=$(date +%s)
    
    echo "$series|$episode|$title|$timestamp" >> "$HISTORY_FILE"
    tail -n 50 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
}

get_last_watched() {
    local series="$1"
    grep "^$series|" "$HISTORY_FILE" 2>/dev/null | tail -1 | cut -d'|' -f2
}

show_history() {
    if [ -s "$HISTORY_FILE" ]; then
        log "üì∫ Watch History:"
        echo "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
        while IFS='|' read -r series episode title timestamp; do
            local date_str=$(date -d "@$timestamp" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "N/A")
            printf "‚îÇ %-40s Episode %-3s (%s) ‚îÇ\n" "$title" "$episode" "$date_str"
        done < <(tac "$HISTORY_FILE" 2>/dev/null | head -10)
        echo "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
    else
        log "No watch history yet"
    fi
}

# ==================== CORE FUNCTIONS ====================

normalize_url() {
    local url="$1"
    [[ "$url" == //* ]] && echo "https:$url" || echo "$url"
}

extract_video_sources() {
    local episode_url="$1"
    
    local cache_key="sources_$(echo -n "$episode_url" | md5sum | cut -d' ' -f1)"
    local cached=$(cache_get "$cache_key")
    [ -n "$cached" ] && { echo "$cached"; return; }
    
    debug "Extracting sources from: $episode_url"
    
    local sources=$(curl -s -L -A "$USER_AGENT" "$episode_url" | \
        grep -oP 'data-src="\K[^"]+' | \
        while read -r url; do
            normalize_url "$url"
        done | \
        sort -u)
    
    cache_set "$cache_key" "$sources"
    echo "$sources"
}

get_mp4upload_video() {
    local embed_url="$1"
    
    debug "Processing mp4upload.com embed"
    
    local embed_html=$(curl -s -L -A "$USER_AGENT" "$embed_url")
    local video_url=""
    
    video_url=$(echo "$embed_html" | grep -oP 'iframe[^>]+src="\K[^"]+' | head -1)
    [ -z "$video_url" ] && video_url=$(echo "$embed_html" | grep -oP 'file\s*:\s*["'\'']\K[^"'\'']+' | \
        grep -i '\.mp4\|\.m3u8\|\.mpd' | head -1)
    [ -z "$video_url" ] && video_url=$(echo "$embed_html" | grep -oP 'https?://[^"\s<>]+\.(mp4|m3u8|mpd|mkv|webm)[^"\s<>]*' | head -1)
    [ -z "$video_url" ] && video_url=$(echo "$embed_html" | grep -oP '"sources"\s*:\s*\[\s*{\s*"file"\s*:\s*"\K[^"]+' | head -1)
    
    if [ -z "$video_url" ]; then
        local video_id=$(echo "$embed_html" | grep -oP 'file\s*=\s*["'\'']\K[^"'\'']+' | head -1)
        [ -n "$video_id" ] && video_url="https://www.mp4upload.com/$video_id"
    fi
    
    if [ -n "$video_url" ]; then
        [[ "$video_url" != http* ]] && video_url="https:$video_url"
        echo "$video_url"
        return 0
    fi
    
    yt-dlp -g "$embed_url" 2>/dev/null | head -1
}

get_playable_url() {
    local source_url="$1"
    
    debug "Processing: $(basename "$source_url")"
    
    if [[ "$source_url" == *"mp4upload.com"* ]]; then
        get_mp4upload_video "$source_url"
        return $?
    fi
    
    local video_url=$(yt-dlp -g "$source_url" 2>/dev/null)
    [ -n "$video_url" ] && echo "$video_url" && return 0
    
    case "$source_url" in
        *"drive.google.com"*)
            local drive_id=$(echo "$source_url" | grep -oP '/d/([^/]+)' | cut -d/ -f3)
            [ -n "$drive_id" ] && echo "https://drive.google.com/uc?id=$drive_id&export=download" && return 0
            ;;
    esac
    
    return 1
}

select_best_source() {
    local episode_url="$1"
    
    local sources=$(extract_video_sources "$episode_url")
    [ -z "$sources" ] && die "No video sources found"
    
    local source_count=$(echo "$sources" | wc -l)
    log "üì° Found $source_count source$( [ $source_count -ne 1 ] && echo s )"
    
    for preferred in "${PREFERRED_SOURCES[@]}"; do
        local source=$(echo "$sources" | grep -i "$preferred" | head -1)
        [ -z "$source" ] && continue
        
        log "Trying: $preferred"
        local video_url=$(get_playable_url "$source")
        
        if [ -n "$video_url" ] && [[ "$video_url" != *".css" ]] && [[ "$video_url" != *".js" ]]; then
            log "‚úÖ Source found!"
            echo "$video_url"
            return 0
        fi
    done
    
    warn "üîÑ Trying fallback sources..."
    while read -r source; do
        local video_url=$(get_playable_url "$source")
        if [ -n "$video_url" ] && [[ "$video_url" != *".css" ]] && [[ "$video_url" != *".js" ]]; then
            warn "‚úÖ Fallback works!"
            echo "$video_url"
            return 0
        fi
    done <<< "$sources"
    
    warn "üåê Trying direct episode page..."
    local video_url=$(yt-dlp -g "$episode_url" 2>/dev/null | head -1)
    [ -n "$video_url" ] && warn "‚úÖ Direct link works!" && echo "$video_url" && return 0
    
    die "‚ùå No playable sources found"
}

# ==================== OKANIME FUNCTIONS ====================

search_okanime() {
    local query="$1"
    log "üîç Searching: $query"
    
    local cache_key="search_$(echo -n "$query" | md5sum | cut -d' ' -f1)"
    local cached=$(cache_get "$cache_key")
    [ -n "$cached" ] && { echo "$cached"; return; }
    
    local encoded_query=$(printf "%s" "$query" | sed 's/ /+/g')
    local search_url="${OKANIME_BASE}/search/?s=${encoded_query}"
    
    local html=$(curl -s -L -A "$USER_AGENT" "$search_url")
    
    local results=$(echo "$html" | awk '
        /<a href="https:\/\/ok\.okanime\.xyz\/anime\/[^"]+"/ {
            match($0, /href="([^"]+)"/, arr)
            url = arr[1]
            get_title = 1
            next
        }
        get_title && /<h3>/ {
            match($0, /<h3>([^<]+)</, arr)
            if (arr[1]) {
                print url "\t" arr[1]
                get_title = 0
            }
        }
    ' | sort -u)
    
    cache_set "$cache_key" "$results"
    echo "$results"
}

get_episodes_from_series() {
    local series_url="$1"
    
    log "üì∫ Loading episodes..."
    
    local cache_key="episodes_$(echo -n "$series_url" | md5sum | cut -d' ' -f1)"
    local cached=$(cache_get "$cache_key")
    [ -n "$cached" ] && { echo "$cached"; return; }
    
    local html=$(curl -s -L -A "$USER_AGENT" "$series_url")
    
    local episodes=$(echo "$html" | grep -oE 'href="https://ok\.okanime\.xyz/episode/[^"]+"' | \
        sed 's/href="//;s/"//' | \
        sort -u | \
        while read -r url; do
            local clean_url=$(echo "$url" | sed 's/%D8%A7%D9%84%D8%AD%D9%84%D9%82%D8%A9/ÿßŸÑÿ≠ŸÑŸÇÿ©/g')
            local ep_num=$(echo "$clean_url" | grep -oE '([0-9]+)-ÿßŸÑÿ≠ŸÑŸÇÿ©' | grep -oE '[0-9]+' || \
                          echo "$clean_url" | grep -oE 'episode-([0-9]+)' | grep -oE '[0-9]+' || \
                          echo "?")
            echo -e "${ep_num}\tEpisode ${ep_num}\t${url}"
        done | sort -V -k1,1n)
    
    cache_set "$cache_key" "$episodes"
    echo "$episodes"
}

extract_title_from_url() {
    local url="$1"
    echo "$url" | sed '
        s|.*/episode/||;
        s|-ÿßŸÑÿ≠ŸÑŸÇÿ©.*||;
        s/%D8%A7%D9%84%D8%AD%D9%84%D9%82%D8%A9//g;
        s/[0-9]\+-*//g;
        s/-/ /g;
        s/^\s*//; s/\s*$//;
        s/\b\(.\)/\u\1/g;
        s/\/$//;
        s/ $//'
}

# ==================== PLAYBACK FUNCTIONS ====================

play_episode() {
    local episode_url="$1"
    local title="$2"
    local episode_num="$3"
    
    local clean_title=$(echo "$title" | sed 's/%[0-9A-F][0-9A-F]//g; s/\/$//; s/ $//')
    [ -z "$clean_title" ] && clean_title="Anime Episode"
    
    log "üé¨ Playing: $clean_title $( [ -n "$episode_num" ] && echo "- Episode $episode_num" )"
    
    local video_url=$(select_best_source "$episode_url")
    [ -z "$video_url" ] && die "Failed to get video URL"
    
    add_to_history "$clean_title" "$episode_num" "$clean_title Episode $episode_num"
    
    log "üöÄ Launching player..."
    
    local mpv_opts=("--force-media-title=$clean_title")
    [ -n "$MPV_OPTIONS" ] && mpv_opts+=($MPV_OPTIONS)
    
    if ! $DEFAULT_PLAYER "${mpv_opts[@]}" "$video_url" 2>/dev/null; then
        warn "üîÑ Trying with different options..."
        $DEFAULT_PLAYER "${mpv_opts[@]}" --no-cache --cache=no "$video_url" 2>/dev/null
    fi
}

# ==================== USER INTERFACE ====================

interactive_select() {
    local query="$1"
    
    local series_results=$(search_okanime "$query")
    [ -z "$series_results" ] && die "No results found"
    
    local selected_series
    if command -v fzf >/dev/null; then
        selected_series=$(printf "%b" "$series_results" | fzf --reverse --with-nth=2.. --prompt="üéå Select anime: " | cut -f1)
    else
        log "Results:"
        printf "%b" "$series_results" | cut -f2 | cat -n
        printf "Enter number: "
        read -r choice
        selected_series=$(printf "%b" "$series_results" | sed -n "${choice}p" | cut -f1)
    fi
    [ -z "$selected_series" ] && die "No selection"
    
    local episodes=$(get_episodes_from_series "$selected_series")
    [ -z "$episodes" ] && die "No episodes found"
    
    local series_title=$(extract_title_from_url "$selected_series")
    local last_ep=$(get_last_watched "$series_title")
    [ -n "$last_ep" ] && log "üìù Last watched: Episode $last_ep"
    
    local selected_episode
    if command -v fzf >/dev/null; then
        selected_episode=$(printf "%s\n" "$episodes" | fzf --reverse --with-nth=1,2 --prompt="üé¨ Select episode: " --header="Last: Episode $last_ep")
    else
        printf "%s\n" "$episodes" | cut -f1,2 | cat -n
        printf "Enter episode number: "
        read -r choice
        selected_episode=$(printf "%s\n" "$episodes" | sed -n "${choice}p")
    fi
    
    local ep_num=$(echo "$selected_episode" | cut -f1)
    local ep_url=$(echo "$selected_episode" | cut -f3)
    
    echo "$ep_url"
    echo "$ep_num"
}

# ==================== COMMAND FUNCTIONS ====================

show_help() {
    show_banner
    cat << EOF
Usage:
  aniar [OPTION]... [QUERY]

Options:
  QUERY                   Search and play anime
  continue SERIES         Continue watching from last episode
  search QUERY            Search without playing
  direct URL [TITLE]      Play direct episode URL
  history                 Show watch history
  config                  Open configuration file
  update                  Check for updates
  clean                   Clear cache
  help                    Show this help

Examples:
  aniar "ŸÜÿßÿ±Ÿàÿ™Ÿà"          # Search and play Naruto
  aniar continue "ŸàŸÜ ÿ®Ÿäÿ≥" # Continue One Piece
  aniar direct "URL"      # Play direct link
  aniar history           # Show watch history

Configuration: $CONFIG_FILE
GitHub: $GITHUB_URL
EOF
}

check_dependencies() {
    local missing=()
    
    command -v curl >/dev/null || missing+=("curl")
    command -v yt-dlp >/dev/null || missing+=("yt-dlp")
    command -v mpv >/dev/null || missing+=("mpv")
    
    if [ ${#missing[@]} -gt 0 ]; then
        die "Missing dependencies: ${missing[*]}"
    fi
}

check_update() {
    log "üîç Checking for updates..."
    local latest=$(curl -s "https://api.github.com/repos/MickaelDLeonhart/aniar/releases/latest" 2>/dev/null | \
        grep -oP '"tag_name": "\K[^"]+' || echo "$VERSION")
    
    if [ "$latest" != "$VERSION" ] && [ "$latest" != "v$VERSION" ]; then
        warn "üì¶ Update available! v$VERSION ‚Üí v$latest"
        warn "Run: curl -sL $GITHUB_URL/raw/main/install.sh | bash"
    else
        log "‚úÖ You have the latest version (v$VERSION)"
    fi
}

clean_cache() {
    if [ -d "$CACHE_DIR" ]; then
        rm -rf "$CACHE_DIR"/*
        log "üßπ Cache cleared"
    else
        log "No cache to clear"
    fi
}

# ==================== MAIN ====================

main() {
    setup_directories
    load_config
    check_dependencies
    
    local query="$*"
    
    if [ -z "$query" ]; then
        show_banner
        printf "Enter anime name: "
        read -r query
    fi
    
    [ -z "$query" ] && die "No search query"
    
    local selection=$(interactive_select "$query")
    local episode_url=$(echo "$selection" | head -1)
    local episode_num=$(echo "$selection" | tail -1)
    
    [ -z "$episode_url" ] && die "No episode selected"
    
    local title=$(extract_title_from_url "$episode_url")
    play_episode "$episode_url" "$title" "$episode_num"
}

# ==================== COMMAND DISPATCH ====================

case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    version|--version|-v)
        show_banner
        ;;
    search)
        [ -z "$2" ] && die "Usage: $0 search QUERY"
        search_okanime "${*:2}" | cat -n
        ;;
    direct)
        [ -z "$2" ] && die "Usage: $0 direct URL [TITLE]"
        play_episode "$2" "${3:-Direct Stream}" "${4:-}"
        ;;
    history)
        show_history
        ;;
    config)
        ${EDITOR:-vi} "$CONFIG_FILE"
        ;;
    update)
        check_update
        ;;
    continue)
        [ -z "$2" ] && die "Usage: $0 continue SERIES_NAME"
        main "${*:2}"
        ;;
    clean)
        clean_cache
        ;;
    debug)
        DEBUG_MODE=1
        shift
        main "$@"
        ;;
    *)
        main "$@"
        ;;
esac
